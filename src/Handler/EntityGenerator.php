<?php

declare(strict_types=1);

namespace EntityGenerator\Handler;

use EntityGenerator\Bridge\Nette\Wrapper\FileWrapper;
use EntityGenerator\Bridge\Nette\Wrapper\NamespaceWrapper;
use EntityGenerator\Bridge\Nette\Wrapper\PropertyWrapper;
use EntityGenerator\Type\PropertyMetaData;
use EntityGenerator\Type\SchemaDefinition;
use EntityGenerator\Component\StringProcessor;
use EntityGenerator\Handler\Property\AtomicType;
use EntityGenerator\Handler\Property\CollectionType;

/**
 * @author Mounir Mouih <mounir.mouih@gmail.com>
 */
class EntityGenerator
{
    /** @var array<FileWrapper> */
    private array $generateFiles = [];

    public function __construct(
        private StringProcessor $stringProcessor,
        private CollectionType $collectionType,
        private AtomicType $atomicType
    ) {
    }

    /**
     * @param array<SchemaDefinition> $schema
     * @return array<FileWrapper>
     */
    public function generate(string $namespace, string $className, array $schema): array
    {
        $this->generateFiles = [];
        $this->generateRecurisivly($namespace, $className, $schema);

        return $this->generateFiles;
    }

    /**
     * @param array<SchemaDefinition> $schema
     */
    private function generateRecurisivly(string $namespace, string $className, array $schema): void
    {
        $namespaceType = new NamespaceWrapper($namespace);
        $class = $namespaceType->addClass($className);
        $class->addComment('Autogenerated Entity');

        foreach ($schema as $propertyName => $definition) {
            $property = $this->createProperty($propertyName);
            $class->addMember($property);

            $propertyMetaData = new PropertyMetaData($property, $definition, $namespaceType);
            if ($definition->hasSchema()) {
                $this->handleComplexType($namespace, $propertyMetaData);
            } else {
                $this->atomicType->handle($propertyMetaData, $definition->type);
            }
        }

        $file = new FileWrapper();
        $file->addNamespace($namespaceType);

        // we save the generated file to be printed later
        $this->generateFiles[$className] = $file;
    }

    private function createProperty(string $propertyName): PropertyWrapper
    {
        $property = new PropertyWrapper($this->stringProcessor->toCamelCase($propertyName));
        $property->setPublic();

        return $property;
    }

    private function handleComplexType(string $namespace, PropertyMetaData $propertyMetaData): void
    {
        $definition = $propertyMetaData->definition;
        $property = $propertyMetaData->property;
        if ($definition->isIterable()) {
            $propertyType = $this->stringProcessor->normalizeClassName($property->getName(), true);
            $this->generateRecurisivly($namespace, $propertyType, $definition->getSchema());
            $this->collectionType->handle($propertyMetaData, $propertyType);
            return;
        }

        $propertyType = $this->stringProcessor->normalizeClassName($property->getName());
        $this->generateRecurisivly($namespace, $propertyType, $definition->getSchema());
        $this->atomicType->handle($propertyMetaData, $propertyType);
    }
}
