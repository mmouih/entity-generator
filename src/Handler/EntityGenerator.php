<?php

declare(strict_types=1);

namespace EntityGenerator\Handler;

use Nette\PhpGenerator\PhpFile;
use Nette\PhpGenerator\Property;
use Nette\PhpGenerator\PhpNamespace;
use EntityGenerator\Type\PropertyMetadata;
use EntityGenerator\Type\SchemaDefinition;
use EntityGenerator\Component\StringProcessor;
use EntityGenerator\Handler\Property\AtomicType;
use EntityGenerator\Handler\Property\CollectionType;

/**
 * @author Mounir Mouih <mounir.mouih@gmail.com>
 */
class EntityGenerator
{
    /** @var array<PhpFile> */
    private array $generateFiles = [];

    /**
     * @param string[] $parameters
     */
    public function __construct(
        private StringProcessor $stringProcessor,
        private CollectionType $collectionType,
        private AtomicType $atomicType,
        private array $parameters
    ) {
    }

    /**
     * @param array<SchemaDefinition> $schema
     * @return array<PhpFile>
     */
    public function generate(string $className, array $schema): array
    {
        $this->generateFiles = [];
        $this->generateRecurisivly($className, $schema);

        return $this->generateFiles;
    }

    /**
     * @param array<SchemaDefinition> $schema
     */
    private function generateRecurisivly(string $className, array $schema): void
    {
        $namespace = new PhpNamespace($this->parameters['namespace']);
        $class = $namespace->addClass($className);
        $class->addComment('Autogenerated Entity');

        foreach ($schema as $propertyName => $definition) {
            $property = $this->createProperty($propertyName);
            $class->addMember($property);

            $propertyMetaData = new PropertyMetaData($property, $definition, $namespace);
            if ($definition->hasSchema()) {
                $this->handleComplexType($propertyMetaData);
            } else {
                $this->atomicType->handle($propertyMetaData, $definition->type);
            }
        }

        $file = new PhpFile();
        $file->addNamespace($namespace);

        // we save the generated file to be printed later
        $this->generateFiles[$className] = $file;
    }

    private function createProperty(string $propertyName): Property
    {
        $property = new Property($this->stringProcessor->toCamelCase($propertyName));
        $property->setPublic();

        return $property;
    }

    private function handleComplexType(PropertyMetadata $propertyMetaData): void
    {
        $definition = $propertyMetaData->definition;
        $property = $propertyMetaData->property;
        if ($definition->isIterable()) {
            $propertyType = $this->stringProcessor->normalizeClassName($property->getName(), true);
            $this->generateRecurisivly($propertyType, $definition->getSchema());
            $this->collectionType->handle($propertyMetaData, $propertyType);
            return;
        }

        $propertyType = $this->stringProcessor->normalizeClassName($property->getName());
        $this->generateRecurisivly($propertyType, $definition->getSchema());
        $this->atomicType->handle($propertyMetaData, $propertyType);
    }
}
